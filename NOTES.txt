cat | cat | cat | ls// checks for file descriptor leaks
ls -l > f1 << END | grep hi | cat > out
la -l < f1 < f2 < f3 > f1 << END | grep hi | cat > out

while (cmd)
	PIPE
	fork_exec(pipe)
	close pipe[1]
	dup2(pipe[0], stdin)
	close pipe[0]

	pid = last_fork
	waitpid (pid, &status, 0);

debug with terminal
	ps aux | grep minishell
	lsof -p (PID)	   check for fd's, hanging processes etc.

quote handling
	test1="ls -l"
	$test1 "$test1"
	ls
	-l
	"$test1"
	<<
	$test
	if (str[i] == '"' || str[i] == '\'')
		i = iter(str + i, str[i]);
	int iter(char *str, char c)
	{
	}



SEGFAULT
	< hey cat > out
	ls | | ls
	| | ls
	| ls
	|
	<
	

bash-3.2$ <
bash: syntax error near unexpected token `newline'
bash-3.2$ |
bash: syntax error near unexpected token `|'
bash-3.2$ <<
bash: syntax error near unexpected token `newline'
bash-3.2$ >>
bash: syntax error near unexpected token `newline'
bash-3.2$ >
bash: syntax error near unexpected token `newline'
bash-3.2$ echo $?
258

"ls" "-l" "-a" | grep u | wc | cat > out > out1 >> out2

TO HANDLE
	<<a<<s<<d (no command)
	check again redir errors for file and multiple redirs (in > >) (<><><><><>)
	add builtin flag
	pass buitin char *
	segfault with ls "-l" | "cat" > out
	segfault with ls "-l" | cat > out
	ok with ls -l | cat > out
	"ls" -l | cat > out has minishell: ls": command not found

	ls -l | awk '{print $3}' //does awk
	ls -l | awk "{print $3}" //does only ls

PROBLEEEEEM
	ls "-lala""lal"
	ls "-""l""a"
	"""$USER"""

----------------------------	>>> should be ok within quotes...

awk
	awk '{print $1, $2}' data.txt
	awk '{sum += $1} END {print sum}' numbers.txt
	awk -F',' '{print $2, $3}' data.csv
	awk '$2 > 80 {print $1}' grades.txt
	awk 'NR>1 {print $1, "is", $2, "years old"}' data.txt

awk '/main/ { print }' minishell.c
awk '/main/ { print }' minishell.c | grep i
char *args[] =			//(execve(awk_path, args, envp))
{
	"awk",				// argv[0] (name of the program)
	"/main/ { print }",	// argv[1] (awk script)
	"minishell.c",		// argv[2] (file to process)
	NULL				// Terminate the argument list with NULL
};

awk '{sum += $1} END {print sum}' numbers.txt
char *args[] =

{
	"awk",							// argv[0] (name of the program)
	"{sum += $1} END {print sum}",	// argv[1] (awk script)
	"numbers.txt",					// argv[2] (file to process)
	NULL							// Terminate the argument list with NULL
};



'' '' '"ls'
ls -"l
echo hi $^^^^^^USE
weird history behaviour


printf("________________________________DEBUG____________________________");
check redirections opening empty file
echo "ls" hello 'lakdghsf"aljghd'ahdgsf"k" > out


	@$(CC) $(CFLAGS) $(SRC) $(LIBFT_AR) $(PRINTF_AR) -o $(NAME) -lreadline
NAME = minishell
CC = cc #-fsanitize=address -g
SRC = awk.c awk_utils.c redir.c builtin_args.c split_ms.c parsing_helper.c parsing_cases.c errors.c quotes.c execution.c parsing.c inpt_handler.c freeing.c minishell.c inpt_functions.c history.c sig_functions.c pwd.c pipe.c echo.c cd.c env.c white_space.c tokenizer.c pipex_functions.c checks.c utils.c expand.c export.c unset.c
CFLAGS = -Wall -Wextra -Werror #-fsanitize=address
RM = rm -rf
LIBFT_AR = Libft/libft.a
PRINTF_AR = printf/libftprintf.a

cc -g -Wall -Wextra -Werror awk.c awk_utils.c redir.c builtin_args.c split_ms.c Libft/libft.a ft_printf/libftprintf.a -o minishell -lreadline

"ls" -l "-l" -a '-a' > "out"
dprintf(2, "__________________DEBUG_____________________\n");

norminette
execution.c

awk '/int/ { print $1 }' minishell.c "pipe.c" | grep i segfault with -fsanitize