cat | cat | cat | ls// checks for file descriptor leaks
la -l > f1 << END | grep hi | cat > out
la -l < f1 < f2 < f3 > f1 << END | grep hi | cat > out

EXECUTE
	if is_bultin
		exec_builtin
	else if number_of_cmds == 1
		exec_simple_cmd
	else
		exec_pipeline

while (cmd)
	PIPE
	fork_exec(pipe)
	close pipe[1]
	dup2(pipe[0], stdin)
	close pipe[0]

	pid = last_fork
	waitpid (pid, &status, 0);

debug with terminal
	ps aux | grep minishell
	lsof -p (PID)       check for fd's, hanging processes etc.

quote handling
	test1="ls -l"
	$test1 "$test1"
	ls
	-l
	"$test1"
	<<
	$test
	if (str[i] == '"' || str[i] == '\'')
		i = iter(str + i, str[i]);
	int iter(char *str, char c)
	{
	}



SEGFAULT
	< hey cat > out
	ls | | ls
	| | ls
	| ls
	|
	<
	

bash-3.2$ <
bash: syntax error near unexpected token `newline'
bash-3.2$ |
bash: syntax error near unexpected token `|'
bash-3.2$ <<
bash: syntax error near unexpected token `newline'
bash-3.2$ >>
bash: syntax error near unexpected token `newline'
bash-3.2$ >
bash: syntax error near unexpected token `newline'
bash-3.2$ echo $?
258

"ls" "-l" "-a" | grep u | wc | cat > out > out1 >> out2

TO HANDLE
	<<a<<s<<d (no command)
	check again redir errors for file and multiple redirs (in > >) (<><><><><>)
	add builtin flag
	pass buitin char *
	segfault with ls "-l" | "cat" > out
	segfault with ls "-l" | cat > out
	ok with ls -l | cat > out
	"ls" -l | cat > out has minishell: ls": command not found

	ls -l | awk '{print $3}' //does awk
	ls -l | awk "{print $3}" //does only ls

PROBLEEEEEM
	ls "-lala""lal"
	ls "-""l""a"
	ls "-la" | cat "-e"
	ls "-la" | grep "ha"
	ls "-la" | grep ha > "file2"
	"""$USER"""